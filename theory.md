# Общая теория по АИСД

[Сложность алгоритмов](#сложность-алгоритмов):
- [Big $O$ notation](#big-o-notation)
- [Big $\theta$ notation](#big-theta-notation)
- [Big $\omega$ notation](#big-omega-notation)
- [Примеры сложностей алгоритмов](#примеры-сложностей-алгоритмов)

***

## Сложность алгоритмов

Бывает несколько видов сложности:
- Сложность времени (time complexity)
- Сложность памяти (memory complexity)

На самом деле ничего сложного нет, просто сложность времени зависит от того, сколько операций выполнит алгоритм прежде
чем выдаст результат, а сложность памяти показывает количество задействованной памяти (дополнительной), которая 
понадобилась во время выполнения алгоритма

***

### Big $O$ notation

Обозначает зависимость количества входящий элементов в алгоритм и время его выполнения. Показывает время в худшем 
случае, то есть когда создается "неудобная" ситуация для алгоритма

### Big $\theta$ notation

Так же обозначает зависимость, но в этом случае идет ранжирование от худшего до лучшего случая выполнения алгоритма

### Big $\Omega$ notation

Все так же обозначает зависимость, но тут это обозначение показывает нижнюю границу, то есть скорость количество
операций для алгоритма в лучшем случае

### Примеры сложностей алгоритмов

- $O(1)$ — обращение к элементу массива
- $O(logn)$ — бинарный поиск
- $O(n)$ — линейный поиск
- $O(nlogn)$ — скорость "быстрых" сортировок
- $O(n^2)$ — скорость "квадратичных" сортировок, обход 2D-матрицы
- $O(n^3)$ — получение троек чисел в массиве длиной n
- $O(2^n)$ — генерация всех подмножеств множества длиной n
- $O(n!)$ — задача о коммивояжере

***

