## Классификация сортирировок

Есть несколько основных типов сортировок (всего 3), на которые обычно разделяются все сортировки

- Квадратичные сортировки (сложность - O(n^2))
  - Пузырьковая сортировка (Bubble sort)
  - Сортировка вставками (Insertion sort)
  - Сортировка выбором (Selection sort)
- Быстрые сортировки (сложность - O(nlogn))
  - Быстрая сортировка (Quick sort)
  - Сортировка Хоара (Hoar sort)
  - Сортировка слиянием (Merge sort)
- Другие
  - Сортировка подсчетом (Count sort)

***

### Пузырьковая сортировка (Bubble sort)

**Идея** — за счет попарных сравнений самый большой элемент переходит в правую часть

**Сложность** — O(n^2)

***

### Сортировка вставками (Insertion sort)

**Идея** — для каждого входящего элемента последовательности алгоритм ищет подходящее место для вставки в уже
отсортированном массиве

**Сложность** — O(n^2)

Эта сортировка — **inplace**, то есть она ничего не возвращает, а изменяет массив, который передали в функцию

***

### Сортировка выбором (Selection sort)

**Идея** — в неотсортированной части массива ищется минимальный элемент. Этот минимальный элемент меняется местами с 
последним элементом в отсортированной части массива. Алгоритм выполняется до того момента, пока не останется элементов в 
неотсортированной части массива

**Сложность** — O(n^2)

Эта сортировка — **inplace**, то есть она ничего не возвращает, а изменяет массив, который передали в функцию

***

### Быстрая сортировка (quicksort)

**Идея** — ищется “опорный” элемент, с которым сравнивается весь список, который рекуррентно "проваливается" опять 
в Quick Sort, пока длины списков не станут меньше или равны одному

**Сложность** — O(nlogn)

***

### Сортировка Хоара (Hoar sort)

**Идея** — схема Хоара использует два индекса (один в начале массива, другой в конце), которые приближаются друг к другу, 
пока не найдётся пара элементов, где один больше опорного и расположен перед ним, а второй меньше и расположен после. 
Эти элементы меняются местами. Обмен происходит до тех пор, пока индексы не пересекутся. Алгоритм возвращает последний индекс.

**Сложность** — O(nlogn)

Эта сортировка — **inplace**, то есть она ничего не возвращает, а изменяет массив, который передали в функцию

***

### Сортировка слиянием (Merge sort)

**Идея** — делить массив на две части (и каждую образовавшуюся) часть до тех пор, пока не образуется много "единичных" массивов.
Тогда после мы сравниваем пары таких массивов и ставим их в правильном порядке (отсортированном)

Сортировка слиянием — отличный пример алгоритма "разделяй и властвуй", когда большую подзачачу дробят на несколько маленьких,
более легких и примитивных

Эта сортировка — **inplace**, то есть она ничего не возвращает, а изменяет массив, который передали в функцию

**Сложность** — O(nlogn)

***

### Сортировка подсчетом (Count sort)

Особенности:
- Обязан быть список целых неотрицательных чисел!

Алгоритм:
- Считываем список a и находим его максимум M. (Максимум находится за O(n))
- Создаем список b размера M + 1, заполняем его нулями
- Проходимся по списку a, заполняем список b следующим образом: b[x] += 1
- Проходимся по списку a и последовательно перезаполняем его из списка b