# Структуры данных

- Статический массив
- Динамический массив
- Односвязный список
- Двусвязный список
- Очередь (queue)
- Стэк (stack)
- Бинарное дерево

***

## Статический массив

**Статический массив** — набор элементов **фиксированной длины**, **фиксированного типа данных**. Он занимает цельное
непрерывное место в памяти

**Преимущества:**

- Скорость доступа к произвольному элементу для записи/чтения за O(1)
- Просто реализуется, удобен для небольших наборов данных

**Недостатки:**

- Хранение данных в непрерывной области памяти, неудобен для больших объемов данных
- Статический массив не способен менять свой размер по ходу выполнения программы. Если места в таком массиве окажется
  недостаточно, данные просто потеряются
- Вставка и удаление элементов происходит за O(n), что может негативно сказаться на больших объемах данных

***

## Динамический массив

**Динамический массив** — массив, который может менять число своих элементов в процессе работы программы

Динамические массивы реализованы на основе обычных статических массивов и хранят данные в непрерывной области памяти.
Операция доступа выполняется за O(1)

Если начального физического размера массива недостаточно, то создается новый массив размером в несколько раз больше
предыдущего с копированием всех прежних значений. Чаще всего происходит удвоение размера

Вычислительная сложность операции вставки/удаления составляет O(n), где n — общий размер динамического массива

***

## Односвязный список

**Недостатки динамических массивов:**

- Если длины не хватает, то создается новый массив с большей длиной и происходит копирование старого за O(n)
- Если длина большая, сложно найти место в памяти

**Добавление нового элемента**:

- Нужно переопределить next последнего элемента на data нового последнего элемента, а tail переприсваивается на Node
  нового элемента — O(1)

**Поиск элемента:**

node = node.next

Время — долго, O(n)

**Вставка элемента:**

next левого — data нового — left.next = node

next нового — data правого — node.next = right

O(n) — вставка элемента

**Преимущества односвязных списков:**

- Добавление нового элемента в начала списка происходит за O(1)
- Если есть указатель на произвольный элемент списка, то вставка после него выполняется за O(1)
- Память выделяется только под фактическое число элементов
- Эффективнее распределяется память между элементами (не используется ненужная, дополнительная память)

***

## Двусвязный список

Аналогичен односвязному списку, но у каждого элемента есть еще атрибут **prev** — ссылка на предыдущий элемент (поэтому
и называют двусвязным)

Добавление элемента в начало и конец списка: ****O(1)

- Создается новый объект
    - Если добавление в конец — **next** у бывшего последнего ссылается на новый, у нового **prev** ссылается на бывший
      последний, переопределяем **tail**
    - Если добавление в начало — **prev** у бывшего первого ссылается на новый, у нового **next** ссылается на бывший
      первый, переопределяем head

Доступ к произвольному элементу: O(n)

- Просто через **next**, если идешь от **head**, или через **prev**, если идешь от **tail**

Вставка элемента в двусвязный список: O(n)

- Аналогично односвязному, но еще добавляется настройка связи через **prev**

Удаление промежуточных элементов: O(n)

- Получить ссылки объектов слева и справа от удаляемого
- Переопределить **next** левого объекта на правый элемент и **prev** правого на левый элемент

Удаление первого или последнего элемента: O(1)

- Создаем указатель на второй элемент
- Приравниваем у второго элемента ссылку **prev** на None
- Переопределяем **head**

***

## Очередь (queue)

**Существует два типа очередей**:

- **FIFO** (First in, first out — первый зашел, первый вышел). Пример использования — система обработки заказов
  интернет-магазина
- **LIFO** (Last in, first out) — последний пришел, первый вышел. Пример — стэк вызова рекурсивных функций, когда один
  вызов накладывается на другой

Для реализации очередей часто используются двусвязные списки, их называют еще deque — double ended queue

Очередь типа **LIFO** — push_front(), pop_back()
Очередь типа **FIFO** — push_front(), pop_back()

***

### Стэк (Stack)

**Стэк** — структура данных типа **LIFO**

**Отличие стэков от очередей FIFO** — в стэке нельзя обратиться к произвольному индексу (только взять "сверху")

Стэк можно реализовать также, как и очередь — с помощью односвязного списка или динамического массива

***

### Бинарное дерево (binary tree)

**Вершина, от которой следуют все остальные** — корень дерева (root)

**Все остальные вершины** — узлы дерева (nodes)

**Бинарное дерево** — дерево, содержащее не более двух потомков

Каждая вершина содержит атрибуты data, left, right

**data** — данные

**left** — левая вершина

**right** — правая вершина

**Уровень дерева** — сколько вершин надо пройти, чтобы дойти до конкретного узла

**Формирование бинарного дерева**:

- если добавляемое значение меньше значения в родительском узле, то новая вершина добавляется в левую ветвь,
иначе — в правую
- если добавляемое значение уже присутствует в дереве, то оно игнорируется, то есть дубли отсутствуют

**Из-за такой особенности возникают**:
- Поиск в бинарном дереве занимает O(logn) времени — но только в **сбалансированном дереве**!!!

**Сбалансированное дерево** — дерево, в котором поддеревья от одной вершины отличаются не более, чем на один уровень

**Методы балансировки деревьев**:
- AVL-дерево (AVL tree)
- красно-черное дерево (red-black tree)
- расширяющееся или косое дерево (splay tree)