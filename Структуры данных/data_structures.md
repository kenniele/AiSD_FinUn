# Структуры данных

- Статический массив
- Динамический массив
- Односвязный список
- Двусвязный список
- Бинарное дерево



## Статический массив

**Статический массив** — набор элементов **фиксированной длины**, **фиксированного типа данных**. Он занимает цельное непрерывное место в памяти

**Преимущества:**

- Скорость доступа к произвольному элементу для записи/чтения за O(1)
- Просто реализуется, удобен для небольших наборов данных

**Недостатки:**

- Хранение данных в непрерывной области памяти, неудобен для больших объемов данных
- Статический массив не способен менять свой размер по ходу выполнения программы. Если места в таком массиве окажется недостаточно, данные просто потеряются
- Вставка и удаление элементов происходит за O(n), что может негативно сказаться на больших объемах данных


## Динамический массив

**Динамический массив** — массив, который может менять число своих элементов в процессе работы программы

Динамические массивы реализованы на основе обычных статических массивов и хранят данные в непрерывной области памяти. Операция доступа выполняется за O(1)

Если начального физического размера массива недостаточно, то создается новый массив размером в несколько раз больше предыдущего с копированием всех прежних значений. Чаще всего происходит удвоение размера

Вычислительная сложность операции вставки/удаления составляет O(n), где n — общий размер динамического массива

## Односвязный список

**Недостатки динамических массивов:**

- Если длины не хватает, то создается новый массив с большей длиной и происходит копирование старого (ресурсоемко, O(n))
- Если длина большая, сложно найти место в памяти

**Добавление нового элемента**:

- Нужно переопределить next последнего элемента на data нового последнего элемента, а tail переприсваивается на Node нового элемента — O(1)

**Поиск элемента:**

node = node.next

Время — долго, O(n)

**Вставка элемента:**

next левого — data нового — left.next = node

next нового — data правого — node.next = right

O(n) — вставка элемента

**Преимущества односвязных списков:**

- Добавление нового элемента в начала списка происходит за O(1)
- Если есть указатель на произвольный элемент списка, то вставка после него выполняется за O(1)
- Память выделяется только под фактическое число элементов
- Эффективнее распределяется память между элементами (не используется ненужная, дополнительная память)

## Двусвязный список

Аналогичен односвязному списку, но у каждого элемента есть еще атрибут **prev** — ссылка на предыдущий элемент (поэтому и называют двусвязным)

Добавление элемента в начало и конец списка: ****O(1)

- Создается новый объект
    - Если добавление в конец — **next** у бывшего последнего ссылается на новый, у нового **prev** ссылается на бывший последний, переопределяем **tail**
    - Если добавление в начало — **prev** у бывшего первого ссылается на новый, у нового **next** ссылается на бывший первый, переопределяем head

Доступ к произвольному элементу: O(n)

- Просто через **next**, если идешь от **head**, или через **prev**, если идешь от **tail**

Вставка элемента в двусвязный список: O(n)

- Аналогично односвязному, но еще добавляется настройка связи через **prev**

Удаление промежуточных элементов: O(n)

- Получить ссылки объектов слева и справа от удаляемого
- Переопределить **next** левого объекта на правый элемент и **prev** правого на левый элемент

Удаление первого или последнего элемента: O(1)

- Создаем указатель на второй элемент
- Приравниваем у второго элемента ссылку **prev** на None
- Переопределяем **head**