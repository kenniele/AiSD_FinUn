# Структуры данных

- [Статический массив](#a-nameaстатический-массив)
- [Динамический массив](#динамический-массив)
- [Односвязный список](#односвязный-список)
- [Двусвязный список](#двусвязный-список)
- [Очередь (queue)](#очередь-queue)
- [Стэк (stack)](#стэк-stack)
- [Бинарное дерево](#бинарное-дерево-binary-tree)
- [Множества и словари](#множества-и-словари)
- [Графы](#графы)

***

## Статический массив

**Статический массив** — набор элементов **фиксированной длины**, **фиксированного типа данных**. Он занимает цельное
непрерывное место в памяти

**Преимущества:**

- Скорость доступа к произвольному элементу для записи/чтения за O(1)
- Просто реализуется, удобен для небольших наборов данных

**Недостатки:**

- Хранение данных в непрерывной области памяти, неудобен для больших объемов данных
- Статический массив не способен менять свой размер по ходу выполнения программы. Если места в таком массиве окажется
  недостаточно, данные просто потеряются
- Вставка и удаление элементов происходит за O(n), что может негативно сказаться на больших объемах данных

***

## Динамический массив

**Динамический массив** — массив, который может менять число своих элементов в процессе работы программы

Динамические массивы реализованы на основе обычных статических массивов и хранят данные в непрерывной области памяти.
Операция доступа выполняется за O(1)

Если начального физического размера массива недостаточно, то создается новый массив размером в несколько раз больше
предыдущего с копированием всех прежних значений. Чаще всего происходит удвоение размера

Вычислительная сложность операции вставки/удаления составляет O(n), где n — общий размер динамического массива

***

## Односвязный список

**Недостатки динамических массивов:**

- Если длины не хватает, то создается новый массив с большей длиной и происходит копирование старого за O(n)
- Если длина большая, сложно найти место в памяти

**Добавление нового элемента**:

- Нужно переопределить next последнего элемента на data нового последнего элемента, а tail переприсваивается на Node
  нового элемента — O(1)

**Поиск элемента:**

node = node.next

Время — долго, O(n)

**Вставка элемента:**

next левого — data нового — left.next = node

next нового — data правого — node.next = right

O(n) — вставка элемента

**Преимущества односвязных списков:**

- Добавление нового элемента в начала списка происходит за O(1)
- Если есть указатель на произвольный элемент списка, то вставка после него выполняется за O(1)
- Память выделяется только под фактическое число элементов
- Эффективнее распределяется память между элементами (не используется ненужная, дополнительная память)

***

## Двусвязный список

Аналогичен односвязному списку, но у каждого элемента есть еще атрибут **prev** — ссылка на предыдущий элемент (поэтому
и называют двусвязным)

Добавление элемента в начало и конец списка: ****O(1)

- Создается новый объект
    - Если добавление в конец — **next** у бывшего последнего ссылается на новый, у нового **prev** ссылается на бывший
      последний, переопределяем **tail**
    - Если добавление в начало — **prev** у бывшего первого ссылается на новый, у нового **next** ссылается на бывший
      первый, переопределяем head

Доступ к произвольному элементу: O(n)

- Просто через **next**, если идешь от **head**, или через **prev**, если идешь от **tail**

Вставка элемента в двусвязный список: O(n)

- Аналогично односвязному, но еще добавляется настройка связи через **prev**

Удаление промежуточных элементов: O(n)

- Получить ссылки объектов слева и справа от удаляемого
- Переопределить **next** левого объекта на правый элемент и **prev** правого на левый элемент

Удаление первого или последнего элемента: O(1)

- Создаем указатель на второй элемент
- Приравниваем у второго элемента ссылку **prev** на None
- Переопределяем **head**

***

## Очередь (queue)

**Существует два типа очередей**:

- **FIFO** (First in, first out — первый зашел, первый вышел). Пример использования — система обработки заказов
  интернет-магазина
- **LIFO** (Last in, first out) — последний пришел, первый вышел. Пример — стэк вызова рекурсивных функций, когда один
  вызов накладывается на другой

Для реализации очередей часто используются двусвязные списки, их называют еще deque — double ended queue

Очередь типа **LIFO** — push_front(), pop_back()
Очередь типа **FIFO** — push_front(), pop_back()

***

### Стэк (Stack)

**Стэк** — структура данных типа **LIFO**

**Отличие стэков от очередей FIFO** — в стэке нельзя обратиться к произвольному индексу (только взять "сверху")

Стэк можно реализовать также, как и очередь — с помощью односвязного списка или динамического массива

***

### Бинарное дерево (binary tree)

**Вершина, от которой следуют все остальные** — корень дерева (root)

**Все остальные вершины** — узлы дерева (nodes)

**Бинарное дерево** — дерево, содержащее не более двух потомков

Каждая вершина содержит атрибуты $data$, $left$, $right$:

- $data$ — данные
- $left$ — левая вершина
- $right$ — правая вершина

**Уровень дерева** — сколько вершин надо пройти, чтобы дойти до конкретного узла

**Формирование бинарного дерева ПОИСКА**:

- если добавляемое значение меньше значения в родительском узле, то новая вершина добавляется в левую ветвь,
иначе — в правую
- если добавляемое значение уже присутствует в дереве, то оно игнорируется, то есть дубли отсутствуют

**Из-за такой особенности возникают**:
- Поиск в подобном бинарном дереве занимает O(logn) времени — но только в **сбалансированном дереве**!!!

**Сбалансированное дерево** — дерево, в котором поддеревья от одной вершины отличаются не более, чем на один уровень

**Способы обхода вершин двоичного дерева**:
- Обход в ширину (обход по уровням дерева)
- Обход в глубину (всегда формируется возрастающая последовательность значения)

Также стоит упомянуть о **методах балансировки деревьев**:
- AVL-дерево (AVL tree)
- красно-черное дерево (red-black tree)
- B-tree (непонятно, что такое B в начале)

**Балансировка деревьев** — используется, чтобы максимально оптимизировать хранение данных в деревьях

**Идеальная сбалансированность** — когда все уровни дерева (либо все, кроме одного) полностью заполнены

Так вот, эти методы пытаются сделать идеальную балансировку

***

### Множества и словари

**Множества** — структура с уникальными элементами, могут состоять ТОЛЬКО из **хэшируемых** элементов

**Словари** — как ни странно, это прямой наследник, или даже "родственник" множеств, ведь ключи в этом типе данных — 
тоже только **хэшируемые** элементы

Так вот, что такое **хэшируемые элементы**. Оказывается, это такие элементы, которые можно представить через функцию 
hash() в Python (ну, или проще говоря, неизменяемые типы данных). Например, числа или строки могут быть "пропущены" 
через функцию hash(), а массив — нет

***

### Графы

**Граф** — упорядоченный набор связанных между собой вершин

**Существуют множество алгоритмов для работы с графами**:
- Обход в ширину
- Обход в глубину
- Алгоритм Дейкстры (алгоритм поиска кратчайшего пути от одной вершины к другой)
